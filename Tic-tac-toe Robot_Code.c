/*
 *	Lego EV3 tic-tac-toe robot
 *	RobotC code
 *	Author: Tom Liang
 *	Date: August 6, 2015
 *	Version: 1.1
 *
 *	Note: the sensor and motor values only work for my robot mechanics structure; 
 *	other mechanics configuration requires different sensor and motor values
/*

#pragma config(Sensor, S2,     ,               sensorEV3_Ultrasonic)
#pragma config(Sensor, S3,     TomTouch,       sensorEV3_Touch, modeEV3Bump)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
void Goto(int row, int col);         // go to a particular position from the center
void Back(int row, int col);         // come back from a particular position to the center
void DropBallTo(int row, int col);   // drop a ball to particular position and then come back to the center
void Check(int row, int col);        // check if a cell has human's ball
void Scan(int row, int col);         // go to a particular position from the center, check if ther is a ball on the cell, and finally come back to the center
void dropBall();                     // dispense the ball
void robotMoveForward();             // move forward 1 cell
void robotMoveBackward();            // move backward 1 cell
void robotRotorRight(int degree);    // rotate clockwise by some encoder values
void robotRotorLeft(int degree);	 // rotate counter-clockwise by some encoder values
void MakeDecision();                 // robot make decision (aka: robot move)
void FillBoard();                    // fill the board with all 0
bool RobotMoveFirst;                 // Does the robot go first?
const int quaterTurn=135;            // encoder value to turn 90 degrees (a quater circle)
const int halfTurn=270;              // encoder value to turn 180 degrees (a half circle)
const int sleeptime=1500;            // the waiting time when robot is scanning
int Board[3][3];                     // 3x3 array to record the cell information
int control_1,control_2,i,j,tracker=0,Movetimes=4; //control_1, control_2, i, and j are variables in the nested loop. tracker is used to detect if the robot wins. Movetimes is the maximum times that robot has to move after human's move

task main()
{
	resetBumpedValue(S3);
	FillBoard();
	sleep(5000);
	RobotMoveFirst=(getBumpedValue(S3)>=1);      // if we hit the touch sensor in the first 5 seconds, robot move first; if don't hit, human go first
	if (RobotMoveFirst==true)
	{
		playSound(soundFastUpwardTones);
		DropBallTo(0,0);                 //robot's first move would be Board[0][0] if robot move first
	}
	else
		playSound(soundLowBuzz);
	resetBumpedValue(S3);
	while (tracker<1 || Movetimes>0)         //continue this process if robot is not winning or robot hasn't reached the maxiumum move times
	{
		sleep(500);
		if (getBumpedValue(S3)>=1)    //robot won't move until human player finish his/her move and we hit the touch sensor
		{
			for (i=0;i<3;i++)                       //this nested loop is to scan the cells that marked with 0
				{
					for (j=0;j<3;j++)
						if (Board[i][j]==0)
							Scan(i,j);
				}
			MakeDecision();
			resetBumpedValue(S3);
		}                                    //the if statement below is used to make robot stop when the robot wins the game
	 	if ((Board[0][0]==2 && Board[1][1]==2 && Board[2][2]==0) || (Board[0][0]==2 && Board[2][0]==2 && Board[1][0]==0) || (Board[2][0]==2 && Board[2][2]==2 && Board[2][1]==0)
	 		|| (Board[0][2]==2 && Board[1][1]==2 && Board[2][0]==0) || (Board[0][0]==2 && Board[0][1]==2 && Board[0][2]==2) || (Board[1][1]==1 && Board[0][1]==1 && Board[2][1]==0)
	 		|| (Board[1][0]==2 && Board[1][1]==2 && Board[1][2]==2))
	 	{
	   displayCenteredTextLine(4,"Robot Wins");
	   tracker=tracker+1;
		}
		Movetimes--;           //Robot has to move maximum 4 times after the first time human places the ball
	}
}


void MakeDecision()
{
	if (RobotMoveFirst==true)               // if Robot go first    (AI will take [0][0] first)
	{
		if (Board[0][0]==2 && Board[1][1]==2 && Board[2][2]==0)     //Winning move start
			DropBallTo(2,2);

		else if (Board[0][0]==2 && Board[2][0]==2 && Board[1][0]==0)     //W
			DropBallTo(1,0);

		else if (Board[2][0]==2 && Board[1][1]==2 && Board[0][2]==0)     //W
			DropBallTo(0,2);

		else if (Board[0][0]==2 && Board[2][2]==2 && Board[1][1]==0)     //W
			DropBallTo(1,1);

		else if (Board[2][0]==2 && Board[2][2]==2 && Board[2][1]==0)     //W
			DropBallTo(2,1);

		else if (Board[0][0]==2 && Board[0][2]==2 && Board[0][1]==0)     //W
			DropBallTo(0,1);

		else if (Board[0][2]==2 && Board[1][1]==2 && Board[2][0]==0)     //W
			DropBallTo(2,0);

		else if (Board[0][2]==2 && Board[2][2]==2 && Board[1][2]==0)     //Winning move end
			DropBallTo(1,2);

		else if (Board[1][1]==1 && Board[0][2]==0)        // case 1: human's first move is [1][1]
			DropBallTo(0,2);

		else if (Board[1][1]==1 && Board[0][2]==2 && Board[0][1]==1 && Board[2][1]==0)
			DropBallTo(2,1);

		else if (Board[1][1]==1 && Board[0][2]==2 && Board[0][1]==1 && Board[2][1]==2 && Board[1][0]==0)
			DropBallTo(1,0);

		else if (Board[1][1]==1 && Board[0][2]==2 && Board[0][1]==1 && Board[2][1]==2 && Board[1][2]==0)
			DropBallTo(1,2);

		else if (Board[1][1]==1 && Board[0][2]==2 && Board[0][1]==1 && Board[2][1]==2 && Board[1][0]==0)
			DropBallTo(1,0);
		//end of case 1              NOTE: non-sense move is in the end of this function

		else if (Board[0][1]==1 && Board[1][1]==0 && Board[0][2]==0 && Board[1][0]==0 && Board[1][2]==0 && Board[2][0]==0 && Board[2][1]==0 && Board[2][2]==0)
			DropBallTo(1,1);   //case 2: human's first move is [0][1]
		else if (Board[0][1]==1 && Board[1][1]==2 && Board[2][2]==1 && Board[2][0]==0)
			DropBallTo(2,0);
		                    //now I have 2 ways: end of case 2

		else if (Board[0][2]==1 && Board[0][1]==0 && Board[1][1]==0 && Board[1][0]==0 && Board[1][2]==0 && Board[2][0]==0 && Board[2][1]==0 && Board[2][2]==0)
			DropBallTo(2,2);     //case 3: human's first move is [0][2]
		else if (Board[0][2]==1 && Board[2][2]==2 && Board[1][1]==1 && Board[2][0]==0)
			DropBallTo(2,0);
		           						//now I have 2 ways; end of case 3

		else if (Board[1][0]==1 && Board[0][1]==0 && Board[1][1]==0 && Board[0][2]==0 && Board[1][2]==0 && Board[2][0]==0 && Board[2][1]==0 && Board[2][2]==0)
			DropBallTo(1,1);     //case 4: human's first move is [1][0]
		else if (Board[1][0]==1 && Board[1][1]==2 && Board[2][2]==1 && Board[0][2]==0)
			DropBallTo(0,2);
	            						//now I have 2 ways: end of case 4

		else if (Board[1][2]==1 && Board[0][1]==0 && Board[1][1]==0 && Board[0][2]==0 && Board[1][0]==0 && Board[2][0]==0 && Board[2][1]==0 && Board[2][2]==0)
			DropBallTo(1,1);    //case 5: human's first move is [1][2]
		else if (Board[1][2]==1 && Board[1][1]==2 && Board[2][2]==1 && Board[0][2]==0)
			DropBallTo(0,2);    //Now I have 2 ways; end of case 5


		else if (Board[2][0]==1 && Board[0][1]==0 && Board[1][1]==0 && Board[0][2]==0 && Board[1][0]==0 && Board[1][2]==0 && Board[2][1]==0 && Board[2][2]==0)
			DropBallTo(2,2);     //case 6: human's first move is [2][0]
		else if (Board[2][0]==1 && Board[2][2]==2 && Board[1][1]==1 && Board[0][2]==0)
			DropBallTo(0,2);    //I have 2 ways: end of case 6


		else if (Board[2][1]==1 && Board[0][1]==0 && Board[1][1]==0 && Board[0][2]==0 && Board[1][0]==0 && Board[1][2]==0 && Board[2][0]==0 && Board[2][2]==0)
			DropBallTo(1,1);   //case 7: human's first move is [2][1]

		else if (Board[2][1]==1 && Board[1][1]==2 && Board[2][2]==1 && Board[2][0]==0)
			DropBallTo(2,0);   //I have 2 ways: end of case 7

		else if (Board[2][2]==1 && Board[0][1]==0 && Board[1][1]==0 && Board[0][2]==0 && Board[1][0]==0 && Board[1][2]==0 && Board[2][0]==0 && Board[2][1]==0)
			DropBallTo(0,2);   //case 8: human's first move is [2][2]
		else if (Board[2][2]==1 && 	Board[0][2]==2 && Board[0][1]==1 && Board[2][0]==0)
			DropBallTo(2,0);   //I have 2 ways: end of case 8
		else
	  	for (control_1=0;control_1<3;control_1++)
	    	for(control_2=0;control_2<3;control_2++)
	      	if (Board[control_1][control_2]==0)
	          {
	            DropBallTo(control_1,control_2);
	            control_1=3;
	            break;
	           }
	}
	//-------------------------------------------------------------------------------------------------------------
	//-------------------------------------------------------------------------------------------------------------
	else if (RobotMoveFirst==false)      //Robot move later
	{
	if (Board[1][1]==1 && Board[0][0]==0)         //case I: human's first move is [1][1]
        DropBallTo(0,0);

    else if (Board[0][0]==2 && Board[0][1]==2 && Board[0][2]==0)     //winning move
        DropBallTo(0,2);

    else if (Board[0][0]==2 && Board[0][2]==2 && Board[0][1]==0)     //winning move
        DropBallTo(0,1);

    else if (Board[0][0]==2 && Board[1][0]==2 && Board[2][0]==0)     //winning move
        DropBallTo(2,0);

    else if (Board[0][0]==2 && Board[2][0]==2 && Board[1][0]==0)     //winning move
        DropBallTo(1,0);

    else if (Board[1][1]==1 && Board[0][1]==1 && Board[2][1]==0 && Board[0][0]==2)
        DropBallTo(2,1);

    else if (Board[1][1]==1 && Board[2][1]==1 && Board[0][1]==0 && Board[0][0]==2)
        DropBallTo(0,1);

    else if (Board[1][1]==1 && Board[2][0]==1 && Board[0][2]==0 && Board[0][0]==2)
        DropBallTo(0,2);

    else if (Board[1][1]==1 && Board[0][2]==1 && Board[2][0]==0 && Board[0][0]==2)    //defensive move
        DropBallTo(2,0);

    else if (Board[1][1]==1 && Board[0][0]==2 && Board[2][2]==1 && Board[0][2]==0)  //defensive move
        DropBallTo(0,2);

    else if (Board[1][1]==1 && Board[0][0]==2 && Board[2][2]==1 && Board[0][2]==2 && Board[0][1]==1 && Board[2][1]==2 && Board[2][0]==1 && Board[1][0]==0)
        DropBallTo(1,0);

    else if (Board[1][1]==0)      //case II: human's first move is NOT [1][1]
        DropBallTo(1,1);

    else if (Board[1][1]==2 && Board[0][0]==2 && Board[2][2]==0)   // W move    diagonoal start
        DropBallTo(2,2);

    else if (Board[1][1]==2 && Board[2][2]==2 && Board[0][0]==0)   // W
        DropBallTo(0,0);

    else if (Board[1][1]==2 && Board[2][0]==2 && Board[0][2]==0)   // W
        DropBallTo(0,2);

    else if (Board[1][1]==2 && Board[0][2]==2 && Board[2][0]==0)   // W      diagonal end
        DropBallTo(2,0);

    else if (Board[1][1]==2 && Board[0][1]==2 && Board[2][1]==0)   // W move     cross start
        DropBallTo(2,1);

    else if (Board[1][1]==2 && Board[2][1]==2 && Board[0][1]==0)   // W
        DropBallTo(0,1);

    else if (Board[1][1]==2 && Board[1][0]==2 && Board[1][2]==0)   // W
        DropBallTo(1,2);

    else if (Board[1][1]==2 && Board[1][2]==2 && Board[1][0]==0)   // W      cross end    Winning move end
        DropBallTo(1,0);

    else if (Board[1][1]==2 && Board[0][0]==1 && Board[0][2]==1 && Board[0][1]==0)  //D move   first row start    Difensive move start
        DropBallTo(0,1);

    else if (Board[1][1]==2 && Board[0][0]==1 && Board[0][1]==1 && Board[0][2]==0)  //D move
        DropBallTo(0,2);

    else if (Board[1][1]==2 && Board[0][1]==1 && Board[0][2]==1 && Board[0][0]==0)  //D move   first row end
        DropBallTo(0,0);

    else if (Board[1][1]==2 && Board[0][0]==1 && Board[2][0]==1 && Board[1][0]==0)  //D move   first column start
        DropBallTo(1,0);

    else if (Board[1][1]==2 && Board[0][0]==1 && Board[1][0]==1 && Board[2][0]==0)  //D move
        DropBallTo(2,0);

    else if (Board[1][1]==2 && Board[1][0]==1 && Board[2][0]==1 && Board[0][0]==0)  //D move   first column end
        DropBallTo(0,0);

    else if (Board[1][1]==2 && Board[2][0]==1 && Board[2][2]==1 && Board[2][1]==0)  //D move   last row start
        DropBallTo(2,1);

    else if (Board[1][1]==2 && Board[2][0]==1 && Board[2][1]==1 && Board[2][2]==0)  //D move
        DropBallTo(2,2);

    else if (Board[1][1]==2 && Board[2][2]==1 && Board[2][1]==1 && Board[2][0]==0)  //D move   last row end
        DropBallTo(2,0);

    else if (Board[1][1]==2 && Board[0][2]==1 && Board[1][2]==1 && Board[2][2]==0)  //D move   last column start
        DropBallTo(2,2);

    else if (Board[1][1]==2 && Board[0][2]==1 && Board[2][2]==1 && Board[1][2]==0)  //D move
        DropBallTo(1,2);

    else if (Board[1][1]==2 && Board[2][2]==1 && Board[1][2]==1 && Board[0][2]==0)  //D move   last column end   Difensive move end
        DropBallTo(0,2);

    else if (Board[1][1]==2 && Board[0][1]==1 && Board[2][1]==1 && Board[2][0]==0)  //winning case
        DropBallTo(2,0);

    else if (Board[1][1]==2 && Board[1][0]==1 && Board[1][2]==1 && Board[0][2]==0)  //winning case
        DropBallTo(0,2);

    else if (Board[1][1]==2 && Board[0][0]==1 && Board[2][2]==1 && Board[2][1]==0)   //if 2 corners are taken
        DropBallTo(2,1);

    else if (Board[1][1]==2 && Board[2][0]==1 && Board[0][2]==1 && Board[2][1]==0)   //same as previous
        DropBallTo(2,1);

    else if (Board[1][1]==2 && Board[0][1]==1 && Board[1][0]==1 && Board[2][0]==0)   //diamond shape start
        DropBallTo(2,0);

    else if (Board[1][1]==2 && Board[0][1]==1 && Board[1][2]==1 && Board[0][0]==0)
        DropBallTo(0,0);

    else if (Board[1][1]==2 && Board[1][0]==1 && Board[2][1]==1 && Board[0][0]==0)
        DropBallTo(0,0);

    else if (Board[1][1]==2 && Board[1][2]==1 && Board[2][1]==1 && Board[2][0]==0)   //diamond shape end
        DropBallTo(2,0);

    else if (Board[1][1]==2 && Board[0][0]==1 && Board[2][1]==1 && Board[1][2]==0)    //special 8 start    [2][1]
        DropBallTo(1,2);

    else if (Board[1][1]==2 && Board[0][2]==1 && Board[2][1]==1 && Board[1][0]==0)    // [2][1]
        DropBallTo(1,0);

    else if (Board[1][1]==2 && Board[1][0]==1 && Board[0][2]==1 && Board[2][1]==0)   //  [1][0]
        DropBallTo(2,1);

    else if (Board[1][1]==2 && Board[1][0]==1 && Board[2][2]==1 && Board[0][1]==0)   //  [1][0]
        DropBallTo(0,1);

    else if (Board[1][1]==2 && Board[0][1]==1 && Board[2][0]==1 && Board[1][2]==0)   //  [0][1]
        DropBallTo(1,2);

    else if (Board[1][1]==2 && Board[0][1]==1 && Board[2][2]==1 && Board[1][0]==0)   //  [0][1]
        DropBallTo(1,0);

    else if (Board[1][1]==2 && Board[1][2]==1 && Board[0][0]==1 && Board[2][1]==0)   //  [1][2]
        DropBallTo(2,1);

    else if (Board[1][1]==2 && Board[1][2]==1 && Board[2][0]==1 && Board[0][1]==0)   //  [1][2]   special 8 end
        DropBallTo(0,1);
    else
        for (control_1=0;control_1<3;control_1++)
            for(control_2=0;control_2<3;control_2++)
                if (Board[control_1][control_2]==0)
                {
                    DropBallTo(control_1,control_2);
                    control_1=3;
                    break;
                }
	}
}

void FillBoard(){
	for(int i=0;i<3;i++)
			for(int j=0;j<3;j++)
				Board[i][j]=0; // Fill the Empty Board
	}

void dropBall()       //Use the motor to drop the ball and prepare the balls to come
{
	resetMotorEncoder(motorA);
	while (getMotorEncoder(motorA)>=-60)
	{
		motor[motorA]=-5;
  }
	while (getMotorEncoder(motorA)<=0)
	{
		motor[motorA]=5;
	}
	motor[motorA]=0;
}

void robotMoveForward()       // robot moves forward 1 cell
{
	resetMotorEncoder(motorC);
	while (getMotorEncoder(motorC)<325)
	{motor[motorC]=6;}
	motor[motorC]=0;
}

void robotMoveBackward()   //robot moves backward 1 cell
{
	resetMotorEncoder(motorC);
	while (getMotorEncoder(motorC)>-325)
	{motor[motorC]=-6;}
	motor[motorC]=0;
}

void robotRotorLeft(int degree)    ////rotate counter-clockwise by some encoder values
{
	resetMotorEncoder(motorB);
	while (getMotorEncoder(motorB)>=-degree)
	{
		motor[motorB]=-10;
		sleep(20);
	}
	  motor[motorB]=0;
}

void robotRotorRight(int degree)    //rotate clockwise by some encoder values
{
	resetMotorEncoder(motorB);
	while (getMotorEncoder(motorB)<=degree)
	{
			motor[motorB]=10;
			sleep(20);
	}
	motor[motorB]=0;
}

void Check(int row, int col)               //this function is to update the Board info
{
	if (getUSDistance(S2)<=9==false)
		Board[row][col]=0;
	else if (getUSDistance(S2)<=9==true && Board[row][col]!=2)
	{
		playSound(soundBeepBeep);
		Board[row][col]=1;
		i=3;                  //this is used to break the nested loop in the main
		j=3;
	}
}

void Goto(int row, int col)
{
		if (row==0 && col==0)            // for [0][0]
			robotMoveBackward();
		else if (row==0 && col==1)                 //for [0][1]
			sleep(100);   //basically don't move
		else if (row==0 && col==2)            //for [0][2]
			robotMoveForward();
		else if (row==1 && col==0)                   //for[1][0]
			robotRotorLeft(quaterTurn);
		else if (row==1 && col==1) {                // for [1][1]
			robotMoveForward();
			robotRotorLeft(quaterTurn);
		}
		else if (row==1 && col==2)               //for [1][2]
			robotRotorRight(quaterTurn);
		else if (row==2 && col==0) {   //for [2][0]
			robotRotorLeft(halfTurn);
			robotMoveBackward();
		}
		else if (row==2 && col==1)    //for [2][1]
			robotRotorLeft(halfTurn);
		else if (row==2 && col==2) {  //for [2][2]
			robotRotorLeft(halfTurn);
			robotMoveForward();
		}
}

void Back(int row, int col)
{
	if (row==0 && col==0)
		robotMoveForward();
	else if (row==0 && col==1)
		sleep(100);
	else if (row==0 && col==2)            //for [0][2]
		robotMoveBackward();
	else if (row==1 && col==0)                   //for[1][0]
		robotRotorRight(quaterTurn);
	else if (row==1 && col==1)  {                 // for [1][1]
		robotRotorRight(quaterTurn);
		robotMoveBackward();
	}
	else if (row==1 && col==2)               //for [1][2]
		robotRotorLeft(quaterTurn);
	else if (row==2 && col==0)  {  //for [2][0]
		robotMoveForward();
		robotRotorRight(halfTurn);
	}
	else if (row==2 && col==1)    //for [2][1]
		robotRotorRight(halfTurn);
	else if (row==2 && col==2) {  //for [2][2]
		robotRotorRight(halfTurn);
		robotMoveBackward();
	}
}

void Scan(int row, int col)    //Scan function
{
	Goto(row,col);
	sleep(sleeptime);
	Check(row,col);
	Back(row,col);
}

void DropBallTo(int row, int col)   // drop a ball to particular position and then come back to the center
{
	Goto(row,col);
	sleep(sleeptime);
	dropBall();
	Board[row][col]=2;
	Back(row,col);
}
